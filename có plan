// ================== MOTOR ==================
#define PWMA 3
#define AIN1 4
#define AIN2 5
#define PWMB 6
#define BIN1 7
#define BIN2 8

// ================== SENSOR ==================
#define S_L1  2
#define S_L2  10
#define S_R1  11
#define S_R2  12

// ================== ULTRASONIC ==================
#define TRIG_PIN 13
#define ECHO_PIN 9
int OBSTACLE_DIST = 25;

// ================== CONFIG ==================
int MAIN_THRESHOLD = 255;
int s[9];

// ================== PID ==================
float Kp = 35.0;
float Ki = 0.0;
float Kd = 120.0;

float error = 0, lastError = 0, integral = 0;

// ================== SPEED ==================
int baseSpeed = 70;
int maxSpeed  = 200;

int pivotFwd = 160;
int pivotRev = -90;

// ================== MAP ==================
int dem_nga = 0;
bool khoa_nga = false;
bool dang_re = false;   // <<< THÊM DUY NHẤT

// ==================================================
void setup() {
  pinMode(PWMA, OUTPUT); pinMode(AIN1, OUTPUT); pinMode(AIN2, OUTPUT);
  pinMode(PWMB, OUTPUT); pinMode(BIN1, OUTPUT); pinMode(BIN2, OUTPUT);

  pinMode(S_L1, INPUT);
  pinMode(S_L2, INPUT);
  pinMode(S_R1, INPUT);
  pinMode(S_R2, INPUT);

  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);

  delay(1000);
}

// ==================================================
void loop() {
  readSensorsDigital();

  // ===== 1. TRÁNH VẬT CẢN =====
  if (!isFrontLost() && getDistance() < OBSTACLE_DIST) {
    handleObstacle();
    return;
  }

  // ===== 2. MẤT LINE =====
  if (isFrontLost()) {
    setMotor(baseSpeed, baseSpeed);
    delay(200);
    resetPID();
    return;
  }

  // ===== 3. NGÃ THẬT =====
  if (nga_that()) {
    if (!khoa_nga) {
      khoa_nga = true;
      dem_nga++;

      // ===== GIỮ NGUYÊN SWITCH CỦA M =====
      switch (dem_nga) {
        case 1:
          diThang(150);
          break;

        case 2:
          diThang(150);
          break;

        case 3:
          rePhai();
          break;

        case 4:
          reTrai();
          break;

        case 5:
          diThang(150);
          break;

        case 6:
          reTrai();
          break;

        case 7:
          diThang(150);
          break;

        case 8:
          reTrai();
          break;

        case 9:
          rePhai();
          break;

        case 10:
          diThang(150);
          break;

        case 11:
          rePhai();
          break;

        case 12:
          diThang(150);
          break;

        case 13:
          diThang(150);
          break;

        case 14:
          diThang(150);
          break;

        default:
          // An toàn nếu vượt số ngã dự kiến
          followLinePID_AnalogOriginal();
          break;
      }
    }
    return;
  }
  else {
    khoa_nga = false;
  }

  // ===== 4. PID =====
  followLinePID_AnalogOriginal();
}

// ==================================================
// ===== RẼ TRÁI – ĐÃ SỬA LOGIC (NHÍCH + 2 PHA) =====
void reTrai() {
  dang_re = true;                 // khóa đếm ngã
  unsigned long t0 = millis();

  // 1. Nhích lên để thoát line cũ
  setMotor(150, 150);
  delay(80);                      // chỉnh 60–100ms tùy xe

  // 2. Quay trái cho tới khi gặp lại line
  while (true) {
    readSensorsDigital();
    setMotor(pivotRev, pivotFwd);

    // Đã bắt lại line mới
    if (s[3] || s[4]) break;

    // An toàn: chống kẹt
    if (millis() - t0 > 2000) break;
  }

  resetPID();
  dang_re = false;                // mở lại đếm ngã
}


// ==================================================
// ===== RẼ PHẢI – ĐÃ SỬA LOGIC (NHÍCH + 2 PHA) =====
void rePhai() {
  dang_re = true;                 // KHÓA đếm ngã
  unsigned long t0 = millis();

  // 1. Nhích lên để thoát line cũ
  setMotor(130, 130);
  delay(80);                      // chỉnh 60–100ms tùy xe

  // 2. Quay phải cho tới khi gặp lại line
  while (true) {
    readSensorsDigital();
    setMotor(pivotFwd, pivotRev);

    // ĐÃ BẮT LẠI LINE MỚI
    if (s[4] || s[5]) break;

    // An toàn: chống kẹt
    if (millis() - t0 > 2000) break;
  }

  resetPID();
  dang_re = false;                // MỞ lại đếm ngã
}

// ==================================================
void diThang(int t) {
  setMotor(180, 180);
  delay(t);
}

// ==================================================
void readSensorsDigital() {
  s[0] = digitalRead(S_L1);
  s[1] = digitalRead(S_L2);

  s[2] = (analogRead(A0) < MAIN_THRESHOLD);
  s[3] = (analogRead(A1) < MAIN_THRESHOLD);
  s[4] = (analogRead(A2) < MAIN_THRESHOLD);
  s[5] = (analogRead(A3) < MAIN_THRESHOLD);
  s[6] = (analogRead(A4) < MAIN_THRESHOLD);

  s[7] = digitalRead(S_R1);
  s[8] = digitalRead(S_R2);
}

// ==================================================
bool isFrontLost() {
  for (int i = 0; i < 9; i++)
    if (s[i]) return false;
  return true;
}

// ==================================================
// ===== NGÃ – CHỈ SỬA ĐÚNG 1 ĐIỀU KIỆN =====
bool nga_that() {
  if (dang_re) return false;   // <<< ĐANG RẼ → KHÔNG ĐẾM NGÃ

  if (s[0] || s[8])
    return true;

  return false;
}

// ==================================================
void followLinePID_AnalogOriginal() {
  int weight[7] = {-3, -2, -1, 0, 1, 2, 3};

  long weightedSum = 0;
  long sum = 0;

  if (s[1]) {
    weightedSum += weight[0] * 200;
    sum += 200;
  }

  for (int i = 0; i < 5; i++) {
    int raw = analogRead(A0 + i);
    int val = (raw < MAIN_THRESHOLD) ? (MAIN_THRESHOLD - raw) : 0;

    weightedSum += (long)val * weight[i + 1];
    sum += val;
  }

  if (s[7]) {
    weightedSum += weight[6] * 200;
    sum += 200;
  }

  if (sum == 0) {
    setMotor(baseSpeed, baseSpeed);
    return;
  }

  float error = (float)weightedSum / sum;
  float derivative = error - lastError;
  lastError = error;

  float pid = Kp * error + Kd * derivative;
  pid = constrain(pid, -baseSpeed, baseSpeed);

  int left  = constrain(baseSpeed + pid, 0, maxSpeed);
  int right = constrain(baseSpeed - pid, 0, maxSpeed);

  setMotor(left, right);
}

// ==================================================
void resetPID() {
  error = lastError = integral = 0;
}

// ==================================================
float getDistance() {
  digitalWrite(TRIG_PIN, LOW); delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH); delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);

  long duration = pulseIn(ECHO_PIN, HIGH, 15000);
  if (duration == 0) return 999;
  return duration * 0.034 / 2;
}

// ==================================================
void handleObstacle() {
  dang_re = true;   // khóa đếm ngã

  // 1. DỪNG XE
  setMotor(0, 0);
  delay(200);

  // 2. QUAY PHẢI ~90° (để hướng xe vuông góc line cũ)
  setMotor(pivotFwd, pivotRev);
  delay(850);   // chỉnh cho đúng 90° với xe m

  // 3. ĐI THẲNG NGANG SÂN (VUÔNG GÓC LINE CŨ)
  setMotor(100, 100);

  // 4. CHỜ TỚI KHI GẶP LINE MỚI (song song line cũ)
  while (true) {
    readSensorsDigital();
    if (s[2] || s[3] || s[4]) break;
  }

  // 5. QUAY TRÁI ĐỂ SONG SONG LINE MỚI
  setMotor(pivotRev, pivotFwd);

  // 6. CHỜ MẮT GIỮA BẮT LINE → ĐÃ BÁM
  while (true) {
    readSensorsDigital();
    if (s[3]) break;
  }

  // 7. TRẢ LẠI PID
  resetPID();
  dang_re = false;
}

// ==================================================
void setMotor(int left, int right) {
  if (left >= 0) { digitalWrite(AIN1, HIGH); digitalWrite(AIN2, LOW); }
  else { digitalWrite(AIN1, LOW); digitalWrite(AIN2, HIGH); left = -left; }

  if (right >= 0) { digitalWrite(BIN1, HIGH); digitalWrite(BIN2, LOW); }
  else { digitalWrite(BIN1, LOW); digitalWrite(BIN2, HIGH); right = -right; }

  analogWrite(PWMA, constrain(left, 0, 255));
  analogWrite(PWMB, constrain(right, 0, 255));
}
