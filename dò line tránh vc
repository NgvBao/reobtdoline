// ================== LINE ROBOT HYBRID (FINAL - OBSTACLE FIX) ==================

// ================== 1. MOTOR & STBY ==================
#define PWMA 3
#define AIN1 4
#define AIN2 5
#define PWMB 6
#define BIN1 7
#define BIN2 8
#define STBY 9

// ================== 2. SENSOR ==================
#define S_GUARD_L  2    // D2
// A0-A4 (5 mắt giữa)
#define S_GUARD_R  12   // D12

#define S_WING_L A5     // Cánh Trái
#define S_WING_R A6     // Cánh Phải

// ================== 3. ULTRASONIC ==================
#define TRIG_PIN 10
#define ECHO_PIN 11
int OBSTACLE_DIST = 17;

// ================== 4. CONFIG ==================
int MAIN_THRESHOLD = 280; 
int WING_THRESHOLD = 500; 

int s[7]; 
// s[0]=D2, s[1]=A0, s[2]=A1, s[3]=A2, s[4]=A3, s[5]=A4, s[6]=D12
int wingL = 0, wingR = 0;

// --- PID SETUP ---
float Kp = 35.0; 
float Ki = 0.0;
float Kd = 120.0;
float error = 0, lastError = 0, integral = 0, PID_val = 0;

// TỐC ĐỘ
int baseSpeed = 110; 
int maxSpeed = 160;  

// --- TỐC ĐỘ RẼ ---
int pivotFwd = 110;  
int pivotRev = -30;  
int spinSpeed = 100; 

void setup() {
  Serial.begin(9600);
  pinMode(PWMA, OUTPUT); pinMode(AIN1, OUTPUT); pinMode(AIN2, OUTPUT);
  pinMode(PWMB, OUTPUT); pinMode(BIN1, OUTPUT); pinMode(BIN2, OUTPUT);
  pinMode(STBY, OUTPUT); digitalWrite(STBY, HIGH);
  
  pinMode(S_GUARD_L, INPUT); pinMode(S_GUARD_R, INPUT);
  pinMode(TRIG_PIN, OUTPUT); pinMode(ECHO_PIN, INPUT);
  
  delay(2000); 
}

void loop() {
  readSensorsDigital(); 

  // 1. TRÁNH VẬT CẢN (Đã sửa nội bộ hàm này)
  if (!isFrontLost() && getDistance() < OBSTACLE_DIST) {
    handleObstacle();
    return;
  }

  // 2. LOGIC CỨU HỘ (Giữ nguyên)
  if (isFrontLost()) {
      if (wingL == 1) { 
          setMotor(-spinSpeed, spinSpeed); 
          while (isFrontLost()) { readSensorsDigital(); } 
          return;
      } 
      if (wingR == 1) { 
          setMotor(spinSpeed, -spinSpeed); 
          while (isFrontLost()) { readSensorsDigital(); } 
          return;
      }
      if (lastError < 0) setMotor(-50, 90); else setMotor(90, -50);                
      return;
  }

  // 3. LOGIC RẼ THƯỜNG (Giữ nguyên)
  if ( (s[1]==1 && s[2]==1) || s[0]==1 ) {
      setMotor(pivotRev, pivotFwd); 
      while ( !((s[2]==1 && s[3]==1) || (s[3]==1 && s[4]==1)) ) { readSensorsDigital(); }
      error = 0; lastError = 0; integral = 0; 
      return;
  }

  if ( (s[5]==1 && s[4]==1) || s[6]==1 ) {
      setMotor(pivotFwd, pivotRev); 
      while ( !((s[2]==1 && s[3]==1) || (s[3]==1 && s[4]==1)) ) { readSensorsDigital(); }
      error = 0; lastError = 0; integral = 0;
      return;
  }

  // 4. PID ANALOG
  followLinePID_AnalogOriginal();
}

// ================== HÀM TRÁNH VẬT CẢN (ĐÃ FIX LỖI DỪNG SỚM) ==================
void handleObstacle() {
  // 1. Phanh
  setMotor(0, 0); delay(200); 

  // 2. Rẽ Phải 90 độ
  setMotor(120, -30); 
  delay(800); 
  
  // 3. ĐI THẲNG TÌM LINE
  setMotor(90, 90); 
  
  // --- BẢO HIỂM: Nhích đi 0.2s để thoát hẳn chỗ cũ ---
  // (Bắt buộc phải có để tránh bị cảm biến sườn nhìn nhầm vạch cũ)
  delay(200); 
  
  // --- LOGIC MỚI: CHỈ TIN MẮT GIỮA (A2) ---
  while (true) {
      readSensorsDigital(); // Đọc cảm biến
      
      // Chỉ khi nào MẮT GIỮA (A2 - s[3]) thấy đen thì mới dừng
      // Các mắt rìa (A0, A4) có nhiễu cũng kệ nó
      if (s[3] == 1) { 
          break; 
      }
  }
  
  // 4. Rẽ Trái QUAY VỀ LINE (Quay: Trái -30, Phải 100)
  setMotor(-30, 100); 
  
  // Điều kiện dừng: Khi A1 (s[2]) VÀ A2 (s[3]) CÙNG THẤY ĐEN
  while ( !(s[2]==1 && s[3]==1) ) { 
      readSensorsDigital(); 
  }
  
  // 5. Thoát (Reset PID)
  error = 0; lastError = 0; integral = 0;
}

// ================== CÁC HÀM CON KHÁC (GIỮ NGUYÊN) ==================

void readSensorsDigital() {
  s[0] = digitalRead(S_GUARD_L); // D2
  s[1] = (analogRead(A0) < MAIN_THRESHOLD) ? 1 : 0;
  s[2] = (analogRead(A1) < MAIN_THRESHOLD) ? 1 : 0;
  s[3] = (analogRead(A2) < MAIN_THRESHOLD) ? 1 : 0; 
  s[4] = (analogRead(A3) < MAIN_THRESHOLD) ? 1 : 0;
  s[5] = (analogRead(A4) < MAIN_THRESHOLD) ? 1 : 0;
  s[6] = digitalRead(S_GUARD_R); // D12

  wingL = (analogRead(S_WING_L) < WING_THRESHOLD) ? 1 : 0;
  wingR = (analogRead(S_WING_R) < WING_THRESHOLD) ? 1 : 0;
}

void followLinePID_AnalogOriginal() {
  float position = 0;
  int weight[5] = {-2, -1, 0, 1, 2};
  long weightedSum = 0;
  long sum = 0;

  for (int i = 0; i < 5; i++) {
    int val = 1023 - analogRead(A0 + i); 
    weightedSum += (long)val * weight[i];
    sum += val;
  }

  if (sum == 0) return; 

  position = (float)weightedSum / (float)sum;

  error = position;
  integral += error;
  integral = constrain(integral, -100, 100);
  
  PID_val = (Kp * error) + (Ki * integral) + (Kd * (error - lastError));
  lastError = error;

  int leftSpeed = constrain(baseSpeed + PID_val, -maxSpeed, maxSpeed);
  int rightSpeed = constrain(baseSpeed - PID_val, -maxSpeed, maxSpeed);
  
  setMotor(leftSpeed, rightSpeed);
}

bool isFrontLost() {
  for (int i=0; i<7; i++) if (s[i] == 1) return false;
  return true; 
}

float getDistance() {
  digitalWrite(TRIG_PIN, LOW); delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH); delayMicroseconds(10); digitalWrite(TRIG_PIN, LOW);
  long duration = pulseIn(ECHO_PIN, HIGH, 15000); 
  if (duration == 0) return 999;
  return (float)duration * 0.034 / 2;
}

void setMotor(int left, int right) {
  if (left >= 0) { digitalWrite(AIN1, HIGH); digitalWrite(AIN2, LOW); }
  else { digitalWrite(AIN1, LOW); digitalWrite(AIN2, HIGH); left = -left; }
  
  if (right >= 0) { digitalWrite(BIN1, HIGH); digitalWrite(BIN2, LOW); }
  else { digitalWrite(BIN1, LOW); digitalWrite(BIN2, HIGH); right = -right; }
  
  analogWrite(PWMA, constrain(left, 0, 255));
  analogWrite(PWMB, constrain(right, 0, 255));
}
